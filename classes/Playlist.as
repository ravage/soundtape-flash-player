package {	import flash.display.*;	public class Playlist extends XSPF {		private var date:String;		private var license:String;		private var tracks:Array;		private var playing:PlaylistItem;		public function Playlist() {			tracks = new Array();		}				public function LoadXSPF() {			var path:String = 'http://hideout.com.br/shows/hideout-48.xspf';			var loadHelper:LoadHelper = new LoadHelper(path, XMLProgress,  XMLLoaded);			loadHelper.LoadXML();		}				public function get Playing():PlaylistItem {			return playing;		}				public function set Playing(value:PlaylistItem) {			playing = value;		}				private function XMLLoaded(data:*) {			var xspf:XML = new XML(data);						if(xspf.localName().toLowerCase() == 'playlist') {				ParsePlaylist(xspf);			}						for each(var node:XML in xspf.children()) {				switch(node.localName().toLowerCase()) {					case 'playlist':					ParsePlaylist(node);					case 'tracklist':					ParseTrackList(node);					break;				}			}						for(var i:int = 0; i < Tracks.length; i++) {				var pli:PlaylistItem = Tracks[i];				pli.y += (pli.height * i);				mcTracks.addChild(pli);			}		}		private function XMLProgress(data:*):void {			trace(data + '%');			//mcPictureFrame.txtMemberInfo.text = data + '%';		}		private function ParsePlaylist(node:XML) {			for each(var playListInfo:XML in node.children()) {				if(playListInfo.localName().toLowerCase() == 'tracklist') {					break;				}				switch(playListInfo.localName().toLowerCase()) {					case 'title':					Title = playListInfo.text();					break;					case 'creator':					Creator = playListInfo.text();					break;					case 'annotation':					Annotation = playListInfo.text();					break;					case 'info':					Info = playListInfo.text();					break;					case 'location':					Location = playListInfo.text();					break;					case 'identifier':					Identifier = playListInfo.text();					break;					case 'image':					Image = playListInfo.text();					break;					case 'date':					PDate = playListInfo.text();					break;					case 'license':					License = playListInfo.text();					break;				}			}		}		private function ParseTrackList(node:XML) {			for each(var tracks:XML in node.children()) {				if(tracks.localName().toLowerCase() == 'track') {					var tempTrack:Track = new Track();					for each(var track:XML in tracks.children()) {						switch(track.localName().toLowerCase()) {							case 'title':							tempTrack.Title = track.text();							break;							case 'creator':							tempTrack.Creator = track.text();							break;							case 'annotation':							tempTrack.Annotation = track.text();							break;							case 'info':							tempTrack.Info = track.text();							break;							case 'location':							tempTrack.Location = track.text();							break;							case 'identifier':							tempTrack.Identifier = track.text();							break;							case 'image':							tempTrack.Image = track.text();							break;							case 'album':							tempTrack.Album = track.text();							break;							case 'tracknum':							tempTrack.TrackNum = track.text();							break;							case 'duration':							tempTrack.Duration = track.text();							break;						}					}					AddTrack(tempTrack);				} 			}		}		public function get PDate():String {			return date;		}		public function set PDate(value:String) {			date = value;		}		public function get License() {			return license;		}		public function set License(value:String) {			license = value;		}				public function AddTrack(track:Track) {			var pli:PlaylistItem = new PlaylistItem(track);			tracks.push(pli);		}				public function get Tracks():Array {			return tracks;		}	}}